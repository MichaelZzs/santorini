{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww12540\viewh11660\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Our first design pattern is the iterator. Our board is a list of lists, where each element in the sublist is a \'93space\'94 class. Thus, in order to iterate through each space in the board, we would have to first flatten the board into a 1d vector before we go through each element, which we use multiple times in our Heuristic player class. Our iterator automates this process and allows use to directly iterate through our board class without additional code that flattens the board into a 1d-array. As a result, our Heuristic player class is a lot cleaner since we do not have extra forloops (or list comprehensions), which detract from readability.\
\
Our second design pattern is the memento design pattern. We used the memento design pattern to solve the redo/undo functionalities of our program. To do this, we saved the board\'92s internal state (a single object) to a memento object (we created classes called Memento and Caretaker). We can also restore a previous state from a moment object by returning the memento object to the originator. What\'92s nice is that the contents of the memento aren\'92t accessible to any other object except the one that produced it (helps solve our encapsulation problem). We applied this design pattern to produce snapshot\'92s of the object\'92s state so that we are able to restore previous states of the object by storing states for the board and workers.\
\
Our third design pattern is the the strategy design pattern. The design pattern was implemented in player.py to create the Human, Random, and Heuristic subclasses. Originally, we had a player class, but since the class did something specific in multiple cases, we extracted all of these algorithms into separate classes. Ultimately, we used to strategy pattern since we had a lot similar classes which differed only in the way they executed some behavior (i.e. in moving the player).\
\
Our fourth design pattern is the command design pattern, which allows us to pass requests as method arguments. We created 3 command classes to simplify running the undo/redo functionalities in main.py, which include the Next, Undo, and Redo command classes. This allows us to transform a specific method call into a stand-alone object so we are able to pass these method arguments at runtime. In other wards, since our code had some awkward dependency since there were all directly implemented by the GUI, we abstracted these request details so that the command class in a single method triggers this request. Ultimately, in the future, this would streamline the process of introducing new commands into our game.}