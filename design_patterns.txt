Our first design pattern is the iterator. Our board is a list of lists, where each element in the sublist is a “space” class. Thus, in order to iterate through each space in the board, we would have to first flatten the board into a 1d vector before we go through each element, which we use multiple times in our Heuristic player class. Our iterator automates this process and allows use to directly iterate through our board class without additional code that flattens the board into a 1d-array. As a result, our Heuristic player class is a lot cleaner since we do not have extra forloops (or list comprehensions), which detract from readability.

Our second design pattern is the memento design pattern. We used the memento design pattern to solve the redo/undo functionalities of our program. To do this, we saved the board’s internal state (a single object) to a memento object. We can also restore a previous state from a moment object by returning the memento object to the originator. What’s nice is that the contents of the memento aren’t accessible to any other object except the one that produced it (helps solve our encapsulation problem). We applied this design pattern to produce snapshot’s of the object’s state so that we are able to restore previous states of the object.

Our third design pattern is the the template design pattern. Within our player class, each player has a different algorithm in building and moving each worker. The template method helps us define the skeleton of this algorithm, and our Human, Random, and Heuristic subclasses subsequently override some specific steps of the algorithm (moving the worker, deciding where to build) without changing its structure. Ultimately, this design pattern allows us to have multiple classes with similar algorithms with minor differences (so we do not need to modify all classes when the algorithm changes).

Our fourth design pattern is the facade design pattern, which provides us with an easier interface to interact with our many other classes. In our PlayGame facade, we are interacting with a multiple of other classes, from the Players, Workers, to the Board. This allows us more convenient access to these subsystems’ functionality and help combines all the moving parts together. Hence, we decided to use a facade design pattern (called PlayGame) to allow a more straightforward interface to a much more complex subsystem.